# README
## template class

拆分模板类

模板不是类或函数——它是用于创建类或函数的模板。因此，它的工作方式与普通函数或类不太一样。在大多数情况下，这不是什么大问题。然而，有一个领域通常会给开发人员带来问题。

对于非模板类，常见的做法是将类定义放在头文件中，将成员函数定义放在同名的代码文件中。这样，成员函数定义就会被编译为单独的项目文件。但是，对于模板，这种方法行不通。

就像函数模板一样，只有当类模板在翻译单元中使用（例如作为 intArray 等对象的类型）时，编译器才会实例化类模板。为了执行实例化，编译器必须看到完整的类模板定义（而不仅仅是声明）和所需的特定模板类型。

还要记住，C++ 是单独编译文件的。编译 main.cpp 时，Array.h 头文件的内容（包括模板类定义）会被复制到 main.cpp 中。当编译器发现我们需要两个模板实例 Array<int> 和 Array<double> 时，它会实例化它们，并将它们编译为 main.cpp 翻译单元的一部分。由于operator[]成员函数有声明，因此编译器会接受对它的调用，假设它会在其他地方定义。

当单独编译 Array.cpp 时，Array.h 头的内容会被复制到 Array.cpp 中，但编译器不会在 Array.cpp 中找到任何需要Array<int>::operator[]实例化 Array 类模板或函数模板的代码 - 因此它不会实例化任何东西。

因此，当程序链接时，我们会收到链接器错误，因为 main.cpp 调用了Array<int>::operator[]该模板函数但从未实例化！

在编译的时候做显式实例化的声明和定义来避免这个问题

## template function

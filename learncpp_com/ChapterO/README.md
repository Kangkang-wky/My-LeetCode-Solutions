## O.1 — 通过 std::bitset 进行位标志和位操作

在现代计算机架构中，内存的最小可寻址单位是字节。由于所有对象都需要具有唯一的内存地址，这意味着对象的大小必须至少为一个字节。对于大多数变量类型，这没问题。但是，对于布尔值，这有点浪费（双关语）。布尔类型只有两种状态：真（1）或假（0）。这组状态只需要一位来存储。但是，如果变量必须至少为一个字节，并且一个字节是 8 位，则意味着布尔值使用 1 位，而其他 7 位未使用。

在大多数情况下，这没问题——我们通常不会因为内存不足而需要关心 7 个浪费的位（我们最好进行优化以提高可理解性和可维护性）。但是，在某些存储密集型情况下，将 8 个单独的布尔值“打包”成一个字节以达到存储效率的目的会很有用。

做这些事情需要我们能够在位级别上操作对象。幸运的是，C++ 为我们提供了执行此操作的工具。修改对象中的单个位称为位操作。

### 位标志

到目前为止，我们已经使用变量来保存单个值：

```c++
int foo { 5 }; // assign foo the value 5 (probably uses 32 bits of storage)
std::cout << foo; // print the value 5
```

但是，我们不应该将对象视为保存单个值，而应该将其视为单个位的集合。当对象的各个位用作布尔值时，这些位称为位标志。

要定义一组位标志，我们通常使用适当大小的无符号整数（8 位、16 位、32 位等...取决于我们有多少个标志）或 std::bitset。

```c++
#include <bitset> // for std::bitset

std::bitset<8> mybitset {}; // 8 bits in size means room for 8 flags
```
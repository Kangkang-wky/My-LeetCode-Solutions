## 20.1 — 函数指针



## 20.2 — 栈和堆

### 段

代码段（也称为文本段），编译后的程序位于内存中。代码段通常是只读的。
bss 段（也称为未初始化数据段），其中存储了零初始化的全局变量和静态变量。
数据段（也称为初始化数据段），存储已初始化的全局变量和静态变量。
堆，动态分配的变量从这里分配。
调用栈，其中存储了函数参数、局部变量和其他与函数相关的信息。


### 堆段

堆段（也称为“空闲存储”）跟踪用于动态内存分配的内存。我们在第 19.1 课“使用 new 和 delete 进行动态内存分配”中已经讨论过堆，因此这里就简单回顾一下。

在 C++ 中，当你使用 new 运算符分配内存时，该内存会被分配在应用程序的堆段中。

假设 int 是 4 个字节：

```c++
int* ptr { new int }; // new int allocates 4 bytes in the heap
int* array { new int[10] }; // new int[10] allocates 40 bytes in the heap
```

该内存的地址由运算符 new 传回，然后可以存储在指针中。您不必担心如何定位和分配空闲内存给用户的过程背后的机制。但是，值得注意的是，连续的内存请求可能不会导致分配连续的内存地址！

```c++
int* ptr1 { new int };
int* ptr2 { new int };
// ptr1 and ptr2 may not have sequential addresses
```

当动态分配的变量被删除时，内存将“返回”到堆，然后可以在收到未来的分配请求时重新分配。请记住，删除指针不会删除变量，它只是将关联地址处的内存返回给操作系统。

#### 堆有优点也有缺点：

- 在堆上分配内存相对较慢。
- 分配的内存保持分配状态，直到被特别释放（注意内存泄漏）或应用程序结束（此时操作系统应该清理它）。
- 动态分配的内存必须通过指针访问。取消引用指针比直接访问变量要慢。
- 因为堆是一个很大的内存池，所以可以在这里分配大型数组、结构或类。

### 调用栈段

调用栈段保存用于调用栈的内存。当应用程序启动时，操作系统会将 main() 函数推送到调用栈上。然后程序开始执行。

当遇到函数调用时，该函数会被推送到调用栈上。当前函数结束时，该函数会从调用栈中弹出（此过程有时称为展开栈）。因此，通过查看当前位于调用栈上的函数，我们可以看到所有被调用的函数，以到达当前执行点。

我们上面的邮箱类比与调用栈的工作方式非常类似。栈本身是一块固定大小的内存地址。邮箱是内存地址，我们在栈上推送和弹出的“项目”称为栈帧。栈帧跟踪与一个函数调用相关的所有数据。我们稍后会详细讨论栈帧。“标记”是一个寄存器（CPU 中的一小块内存），称为栈指针（有时缩写为“SP”）。栈指针跟踪调用栈的顶部当前所在的位置。

我们可以进一步进行优化：当我们从调用栈中弹出一个项目时，我们只需将栈指针向下移动——我们不必清理或将弹出的栈框架使用的内存清零（相当于清空邮箱）。此内存不再被视为“在栈上”（栈指针将位于此地址或以下），因此将无法访问。如果我们稍后将新的栈框架推送到同一内存，它将覆盖我们从未清理过的旧值。

#### 实际的调用栈

让我们更详细地了解一下调用栈的工作原理。以下是调用函数时发生的步骤顺序：

程序遇到函数调用。
构造一个栈框架并将其推送到栈上。栈框架包括：
函数调用之后的指令地址（称为返回地址）。这是 CPU 记住被调用函数退出后返回到哪里的方式。
所有函数参数。
任何局部变量的内存
函数修改的任何寄存器的已保存副本，函数返回时需要恢复这些副本
CPU 跳转到该函数的起始点。
函数内部的指令开始执行。
当函数终止时，会发生以下步骤：

从调用栈恢复寄存器
栈框架从栈中弹出。这将释放所有局部变量和参数的内存。
返回值已处理。
CPU 在返回地址处恢复执行。
返回值可以用多种不同的方式处理，具体取决于计算机的体系结构。某些体系结构将返回值作为栈框架的一部分。其他体系结构使用 CPU 寄存器。

通常，了解调用栈如何工作的所有细节并不重要。但是，了解函数在被调用时被有效地推送到栈上，并在返回时弹出（展开）可以让您了解递归所需的基础知识，以及调试时有用的其他一些概念。

技术说明：在某些架构上，调用栈从内存地址 0 开始增长。在其他架构上，它会朝内存地址 0 增长。因此，新推送的栈帧可能具有比之前的栈帧更高或更低的内存地址。

#### 堆栈溢出

堆栈的大小是有限的，因此只能容纳有限量的信息。在适用于 Windows 的 Visual Studio 中，默认堆栈大小为 1MB。使用 g++/Clang for Unix 变体，堆栈大小可以达到 8MB。如果程序试图在堆栈上放置过多信息，则会导致堆栈溢出。当堆栈中的所有内存都已分配时，就会发生堆栈溢出——在这种情况下，进一步的分配会开始溢出到内存的其他部分。

堆栈溢出通常是由于在堆栈上分配了太多变量，和/或进行了太多嵌套函数调用（其中函数 A 调用函数 B 调用函数 C 调用函数 D 等等...）在现代操作系统上，堆栈溢出通常会导致操作系统发出访问冲突并终止程序。

下面是一个可能导致堆栈溢出的示例程序。您可以在系统上运行它并观察它崩溃的情况：

```c++
#include <iostream>

int main()
{
    int stack[10000000];
    std::cout << "hi" << stack[0]; // we'll use stack[0] here so the compiler won't optimize the array away

    return 0;
}
```
## 2.10 — 预处理器简介

### 翻译单元

预处理器处理完代码文件后，其结果称为**翻译单元**。编译器将编译该翻译单元。

每个翻译单元通常由单个代码（.cpp）文件和它#include 的所有头文件组成（递归应用，因为头文件可以#include 其他头文件）。

### 宏定义

- #define指令可用于创建宏。在 C++ 中，宏是定义如何将输入文本转换为替换输出文本的规则。

- 宏有两种基本类型：类对象宏和类函数宏。

- 函数式宏的作用类似于函数，并且具有类似的用途。它们的使用通常被认为是不安全的，并且它们能做的几乎一切都可以由普通函数完成。



## 2.11 -- 头文件


### 最佳实践

不要将函数和变量定义放在头文件中（目前）。

如果头文件被 #include 到多个源文件 (.cpp) 中，则在头文件中定义其中任何一个都可能会导致违反单一定义规则 (ODR)。


### 规则

使用双引号包含您编写的或预计在当前目录中找到的头文件。使用尖括号包含编译器、操作系统或您在系统其他位置安装的第三方库附带的头文件。



## 2.12 — Header guards

- 好消息是，我们可以通过一种称为header guard（也称为include guard）的机制来避免上述问题。header guard 是条件编译指令，其形式如下：

```c++
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE

// your declarations (and certain types of definitions) here

#endif
```

当此标头被 #included 时，预处理器将检查此翻译单元中是否已定义SOME_UNIQUE_NAME_HERE 。如果这是我们第一次包含标头，则SOME_UNIQUE_NAME_HERE将尚未定义。因此，它会 #define SOME_UNIQUE_NAME_HERE并包含文件的内容。如果标头再次包含到同一个文件中，则SOME_UNIQUE_NAME_HERE将在第一次包含标头内容时就已经定义，并且标头的内容将被忽略（感谢 #ifndef）。


### pragma once

现代编译器支持使用预处理器指令的更简单的替代形式的头保护#pragma：

```c++
#pragma once

// your code here
```

头文件保护的目的是确保给定头文件的内容不会被复制到任何单个文件中超过一次，以防止重复定义。

重复声明是可以的——但即使你的头文件由所有声明（没有定义）组成，包含头文件保护仍然是最佳做法。

请注意，头文件保护不会阻止将头文件的内容（一次）复制到单独的项目文件中。这是一件好事，因为我们经常需要从不同的项目文件中引用给定头文件的内容。